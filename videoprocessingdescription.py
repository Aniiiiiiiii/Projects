# -*- coding: utf-8 -*-
"""VideoProcessingDescription.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1BC-6CyIjeVtuMYVWVmXvejy1Y6VwMAcF
"""

# Dashcam video of driving around San Francisco
video_url = "https://youtu.be/X8gWwdHtTKg?si=TEluT_voJSq3kd_6"

# How much frames to skip
N = 120

# pytube is used to download videos from YouTube
!pip install pytube

# Intall a newer version of plotly
!pip install plotly==4.14.3

# Install CLIP from the GitHub repo
!pip install git+https://github.com/openai/CLIP.git

# Install torch 1.7.1 with GPU support
!pip install torch==1.7.1+cu101 torchvision==0.8.2+cu101 -f https://download.pytorch.org/whl/torch_stable.html

from pytube import YouTube

# Choose a video stream with resolution of 360p
streams = YouTube(video_url).streams.filter(adaptive=True, subtype="mp4", resolution="360p", only_video=True)

# Check if there is a valid stream
if len(streams) == 0:
  raise "No suitable stream found for this YouTube video!"

# Download the video as video.mp4
print("Downloading...")
streams[0].download(filename="video.mp4")
print("Download completed.")

import cv2
from PIL import Image

# The frame images will be stored in video_frames
video_frames = []

# Open the video file
capture = cv2.VideoCapture('video.mp4')
fps = capture.get(cv2.CAP_PROP_FPS)

current_frame = 0
while capture.isOpened():
  # Read the current frame
  ret, frame = capture.read()

  # Convert it to a PIL image (required for CLIP) and store it
  if ret == True:
    video_frames.append(Image.fromarray(frame[:, :, ::-1]))
  else:
    break

  # Skip N frames
  current_frame += N
  capture.set(cv2.CAP_PROP_POS_FRAMES, current_frame)

# Print some statistics
print(f"Frames extracted: {len(video_frames)}")

import clip
import torch

# Load the open CLIP model
device = "cuda" if torch.cuda.is_available() else "cpu"
model, preprocess = clip.load("ViT-B/32", device=device)

import math
import numpy as np
import torch

# You can try tuning the batch size for very large videos, but it should usually be OK
batch_size = 256
batches = math.ceil(len(video_frames) / batch_size)

# The encoded features will bs stored in video_features
video_features = torch.empty([0, 512], dtype=torch.float16).to(device)

# Process each batch
for i in range(batches):
  print(f"Processing batch {i+1}/{batches}")

  # Get the relevant frames
  batch_frames = video_frames[i*batch_size : (i+1)*batch_size]

  # Preprocess the images for the batch
  batch_preprocessed = torch.stack([preprocess(frame) for frame in batch_frames]).to(device)

  # Encode with CLIP and normalize
  with torch.no_grad():
    batch_features = model.encode_image(batch_preprocessed)
    batch_features /= batch_features.norm(dim=-1, keepdim=True)

  # Append the batch to the list containing all features
  video_features = torch.cat((video_features, batch_features))

# Print some stats
print(f"Features: {video_features.shape}")

import plotly.express as px
import datetime
from IPython.core.display import HTML

def search_video(search_query, display_heatmap=True, display_results_count=3):

  # Encode and normalize the search query using CLIP
  with torch.no_grad():
    text_features = model.encode_text(clip.tokenize(search_query).to(device))
    text_features /= text_features.norm(dim=-1, keepdim=True)

  # Compute the similarity between the search query and each frame using the Cosine similarity
  similarities = (100.0 * video_features @ text_features.T)
  values, best_photo_idx = similarities.topk(display_results_count, dim=0)

  # Display the heatmap
  if display_heatmap:
    print("Search query heatmap over the frames of the video:")
    fig = px.imshow(similarities.T.cpu().numpy(), height=50, aspect='auto', color_continuous_scale='viridis')
    fig.update_layout(coloraxis_showscale=False)
    fig.update_xaxes(showticklabels=False)
    fig.update_yaxes(showticklabels=False)
    fig.update_layout(margin=dict(l=0, r=0, b=0, t=0))
    fig.show()
    print()

  # Display the top 3 frames
  for frame_id in best_photo_idx:
    display(video_frames[frame_id])

    # Find the timestamp in the video and display it
    seconds = round(frame_id.cpu().numpy()[0] * N / fps)
    display(HTML(f"Found at {str(datetime.timedelta(seconds=seconds))} (link)"))

search_video("tree")

pip install transformers

from pytube import YouTube

# Dashcam video of driving around San Francisco
video_url = "https://www.youtube.com/watch?v=y1w0JfqcdA8"

# Choose a video stream with resolution of 360p
streams = YouTube(video_url).streams.filter(adaptive=True, subtype="mp4", resolution="360p", only_video=True)

# Check if there is a valid stream
if len(streams) == 0:
  raise "No suitable stream found for this YouTube video!"

# Download the video as video.mp4
print("Downloading...")
streams[0].download(filename="video.mp4")
print("Download completed.")

import cv2
from PIL import Image
from pytube import YouTube
from transformers import VisionEncoderDecoderModel, ViTImageProcessor, AutoTokenizer
import torch

# Load the pre-trained image captioning model, image processor, and tokenizer
model = VisionEncoderDecoderModel.from_pretrained("nlpconnect/vit-gpt2-image-captioning")
feature_extractor = ViTImageProcessor.from_pretrained("nlpconnect/vit-gpt2-image-captioning")
tokenizer = AutoTokenizer.from_pretrained("nlpconnect/vit-gpt2-image-captioning")

device = torch.device("cuda" if torch.cuda.is_available() else "cpu")
model.to(device)

# Define parameters for generating captions
max_length = 16
num_beams = 4
gen_kwargs = {"max_length": max_length, "num_beams": num_beams}

# Open the downloaded video file
video_path = "video.mp4"
video_capture = cv2.VideoCapture(video_path)
fps = video_capture.get(cv2.CAP_PROP_FPS)

# Function to generate descriptions for frames
def generate_descriptions(video_capture, timestamps):
    descriptions = []

    for timestamp in timestamps:
        # Calculate the frame index for the desired timestamp
        frame_index = int(timestamp * fps)

        # Seek to the desired frame
        video_capture.set(cv2.CAP_PROP_POS_FRAMES, frame_index)

        # Read the frame
        ret, frame = video_capture.read()

        if ret:
            # Convert the frame to a PIL image
            input_image = Image.fromarray(frame[:, :, ::-1])  # Convert BGR to RGB

            # Process the image and generate a textual description
            pixel_values = feature_extractor(images=[input_image], return_tensors="pt").pixel_values.to(device)
            output_ids = model.generate(pixel_values, **gen_kwargs)
            preds = tokenizer.batch_decode(output_ids, skip_special_tokens=True)
            descriptions.append(preds[0].strip())
        else:
            descriptions.append("Frame not found at the desired timestamp.")

    return descriptions

# Example usage: provide the timestamps for frame descriptions
timestamps = [1080.0, 1500.0, 1341.0]  # Adjust timestamps as needed

descriptions = generate_descriptions(video_capture, timestamps)
for i, timestamp in enumerate(timestamps):
    print(f"Description for timestamp {timestamp} seconds: {descriptions[i]}")

import torch
from transformers import GPT2LMHeadModel, GPT2Tokenizer
import torchvision.transforms as transforms
from PIL import Image
import requests
import io

# Load a pre-trained language generation model (e.g., GPT-2)
tokenizer = GPT2Tokenizer.from_pretrained("gpt2")
language_model = GPT2LMHeadModel.from_pretrained("gpt2")
language_model.eval()

# Load and preprocess the image
image_url = "https://i.ytimg.com/vi/exc9zbrplyM/maxresdefault.jpg"  # Replace with the URL to your image
response = requests.get(image_url)
image = Image.open(io.BytesIO(response.content))

# Define image transformations (resize and normalize)
image_transforms = transforms.Compose([
    transforms.Resize((224, 224)),
    transforms.ToTensor(),
    transforms.Normalize(mean=[0.485, 0.456, 0.406], std=[0.229, 0.224, 0.225]),
])

# Apply transformations to the image
image = image_transforms(image)

# Generate a textual description for the image using the language model
with torch.no_grad():
    # Encode the image using the language model's tokenizer
    input_text = "A photo of a"
    input_ids = tokenizer.encode(input_text, return_tensors="pt")
    remaining_space = language_model.config.max_length - input_ids.size(1)  # Calculate available space

    # Check if there's enough space for the image tokens
    if remaining_space > image.view(-1).size(0):
        input_ids = torch.cat((input_ids, image.view(1, -1).long()), dim=-1)  # Convert to Long type
    else:
        # Truncate and reshape the image tensor to fit within the available space
        image = image.view(-1)[:remaining_space].view(1, remaining_space).long()
        input_ids = torch.cat((input_ids, image), dim=-1)

    # Generate a textual description
    caption = language_model.generate(input_ids=input_ids)
    description = tokenizer.decode(caption[0], skip_special_tokens=True)
    print("Description:", description)